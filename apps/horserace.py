# -*- coding: utf-8 -*-
"""HorseRace.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ooHIYIag9RwTdQGSBQeB2oR5psKc2atL
"""

import itertools
import random
import streamlit as st

race_len = 3

def take_step(pos, card, back_card, flipped_idx):
    pos[card] += 1
    if pos[card] == race_len: # Game is over, return index of winner
      return card, flipped_idx
    if all([val > flipped_idx for val in pos]): # first time a backwards card is flipped
      pos[back_card] -= 1
      flipped_idx += 1 # increment flipped as this level has already been flipped
    return -1, flipped_idx


def race(pos=[0] * 4): # Outputs the winner as a number
  deck = [0, 1, 2, 3] * 12 # Does not include the 4 racers
  random.shuffle(deck)
  out = -1
  flipped_idx = 1
  while out == -1:
    out, flipped_idx = take_step(pos, deck.pop(), deck[-flipped_idx], flipped_idx) # Ensures that changes to flipped_idx in the take_step function are reflected here
  return out

def generate_unordered_lists(n):
  return [list(c) for c in itertools.combinations_with_replacement(range(n), 4)] # Constructs a list with every possible config up to isomorphism

# Construct all states and probabilities of victory
pos_ls = generate_unordered_lists(race_len)
prob_matrix = [[0] * 4 for i in range(len(pos_ls))]
for i, pos in enumerate(pos_ls):
  cur_pos = pos.copy()
  wins_ls = [0] * 4
  for _ in range(100000):
    wins_ls[race(pos)] += 1
    pos = cur_pos.copy()
  prob_matrix[i] = [x / 100000 for x in wins_ls]

# New section where one can input board state and we ouput share prices
def state_to_probs(state, states_ls): # State is a list of ints
  input_board = list(enumerate(state))
  sorted_input_board = sorted(input_board, key=lambda item: item[1])
  probs = prob_matrix[ states_ls.index(sorted(state)) ]
  true_positional_probs = [0] * 4
  for i, prob in enumerate(probs):
    true_positional_probs[sorted_input_board[i][0]] = prob
  return true_positional_probs

def probs_to_prices(probs):
  return [val * 4 for val in probs]

def state_to_prices(state, state_ls):
  return probs_to_prices( state_to_probs(state, state_ls) )

def state_to_perturbed_prices(state, state_ls):
  prices = probs_to_prices( state_to_probs(state, state_ls) )
  return [max(0, price + random.gauss(0, 0.02 + price*0.05)) for price in prices]

st.title("Horse Race Bank Offers")
input_state = st.text_input("Enter board state (e.g. 0 1 2 1):")

if input_state:
  try:
    state = list(map(int, input_state.split()))
    POS_LS_UNTOUCHED = generate_unordered_lists(race_len)
    prices = state_to_perturbed_prices(state, POS_LS_UNTOUCHED)
    st.write("Offered Prices:", prices)
  except ValueError:
    st.error("Invalid input. Please enter valid integers separated by spaces.")
